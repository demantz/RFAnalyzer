package com.mantz_it.rfanalyzer.device.file;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.SystemClock;
import android.util.Log;

import com.mantz_it.rfanalyzer.IQConverter;
import com.mantz_it.rfanalyzer.IQSource;
import com.mantz_it.rfanalyzer.R;
import com.mantz_it.rfanalyzer.SamplePacket;
import com.mantz_it.rfanalyzer.Signed24BitIQConverter;
import com.mantz_it.rfanalyzer.Signed8BitIQConverter;
import com.mantz_it.rfanalyzer.Unsigned8BitIQConverter;
import com.mantz_it.rfanalyzer.control.Control;
import com.mantz_it.rfanalyzer.sdr.controls.MixerFrequency;
import com.mantz_it.rfanalyzer.sdr.controls.MixerSampleRate;
import com.mantz_it.rfanalyzer.sdr.controls.RXFrequency;
import com.mantz_it.rfanalyzer.sdr.controls.RXSampleRate;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

/**
 * <h1>RF Analyzer - File Source of IQ samples</h1>
 * <p>
 * Module:      FileIQSource.java
 * Description: Simple source of IQ sampling by reading from IQ files generated by the
 * HackRF. Just for testing.
 *
 * @author Dennis Mantz
 *         <p>
 *         Copyright (C) 2014 Dennis Mantz
 *         License: http://www.gnu.org/licenses/gpl.html GPL version 2 or higher
 *         <p>
 *         This library is free software; you can redistribute it and/or
 *         modify it under the terms of the GNU General Public
 *         License as published by the Free Software Foundation; either
 *         version 2 of the License, or (at your option) any later version.
 *         <p>
 *         This library is distributed in the hope that it will be useful,
 *         but WITHOUT ANY WARRANTY; without even the implied warranty of
 *         MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *         General Public License for more details.
 *         <p>
 *         You should have received a copy of the GNU General Public
 *         License along with this library; if not, write to the Free Software
 *         Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */
public class FileIQSource implements IQSource {
private Callback callback = null;
private boolean repeat = false;
private int sampleRate = 0;
long frequency = 0;
private int packetSize = 0;
private int sleepTime = 0;            // min. time (in ms) between two getPacket() calls to simulate the sample rate
private long lastAccessTime = 0;    // timestamp of the last getPacket() call
private byte[] buffer = null;
private File file = null;
private String filename = null;
private BufferedInputStream bufferedInputStream = null;
private IQConverter iqConverter;
private int offset;
private int fileFormat;
private static final String LOGTAG = "FileIQSource";
public static final int FILE_FORMAT_8BIT_SIGNED = 0;
public static final int FILE_FORMAT_8BIT_UNSIGNED = 1;
public static final int FILE_FORMAT_24BIT_SIGNED = 2;
protected boolean reopenStreamStrategy;
protected static final long REOPEN_STREAM_SIZE_THRESHOLD = 2 << 23 - 1; // 8 MB;

private MixerSampleRate mixerSampleRate;
private MixerFrequency mixerFrequency;

public FileIQSource(String filename, int sampleRate, long frequency, int packetSize, boolean repeat, int fileFormat) {
	this.filename = filename;
	this.file = new File(filename);
	this.repeat = repeat;
	this.fileFormat = fileFormat;
	this.sampleRate = sampleRate;
	this.frequency = frequency;
	this.packetSize = packetSize;
	this.buffer = new byte[packetSize * 10];

	switch (fileFormat) {
		case FILE_FORMAT_8BIT_SIGNED:
			Log.w(LOGTAG, "Format: FILE_FORMAT_8BIT_SIGNED");
			iqConverter = new Signed8BitIQConverter();
			offset = 0;
			break;
		case FILE_FORMAT_8BIT_UNSIGNED:
			Log.w(LOGTAG, "Format: FILE_FORMAT_8BIT_UNSIGNED");
			iqConverter = new Unsigned8BitIQConverter();
			offset = 0;
			break;
		case FILE_FORMAT_24BIT_SIGNED:
			Log.w(LOGTAG, "Format: FILE_FORMAT_24BIT_SIGNED");
			iqConverter = new Signed24BitIQConverter();
			offset = 2;
			break;
		default:
			Log.e(LOGTAG, "constructor: Invalid file format: " + fileFormat);
			break;
	}
	Log.w(LOGTAG, "Offset: " + offset);

	this.sleepTime = (int) (((packetSize - offset) / iqConverter.getSampleSize() / 2) / (float) sampleRate * 10000); // note: half packet size because of I and Q samples

	mixerFrequency = iqConverter.getControl(MixerFrequency.class);
	mixerSampleRate = iqConverter.getControl(MixerSampleRate.class);
	mixerFrequency.set(frequency);
	mixerSampleRate.set(sampleRate);
}

public FileIQSource(Context context, SharedPreferences preferences) {
	this.frequency = Integer.parseInt(preferences.getString(context.getString(R.string.pref_filesource_frequency), "97000000"));
	this.sampleRate = Integer.parseInt(preferences.getString(context.getString(R.string.pref_filesource_sampleRate), "2000000"));
	this.file = new File(this.filename = preferences.getString(context.getString(R.string.pref_filesource_file), ""));
	this.fileFormat = Integer.parseInt(preferences.getString(context.getString(R.string.pref_filesource_format), "0"));
	this.repeat = preferences.getBoolean(context.getString(R.string.pref_filesource_repeat), false);
	switch (fileFormat) {
		case FILE_FORMAT_8BIT_SIGNED:
			this.iqConverter = new Signed8BitIQConverter();
			this.packetSize = 16384;
			break;
		case FILE_FORMAT_8BIT_UNSIGNED:
			this.iqConverter = new Unsigned8BitIQConverter();
			this.packetSize = 16384;
			break;
		case FILE_FORMAT_24BIT_SIGNED:
			this.iqConverter = new Signed24BitIQConverter();
			this.packetSize = 1440; //todo: add separate preference for packet size by source type
			offset = 0;
			break;
		default:
			Log.e(LOGTAG, "constructor: Invalid file format: " + fileFormat);
			break;
	}
	this.buffer = new byte[packetSize * 10];
	this.sleepTime = (int) ((packetSize / iqConverter.getSampleSize() / 2) / (float) sampleRate * 10000); // note: half packet size because of I and Q samples
	mixerFrequency = iqConverter.getControl(MixerFrequency.class);
	mixerSampleRate = iqConverter.getControl(MixerSampleRate.class);
	mixerFrequency.set(frequency);
	mixerSampleRate.set(sampleRate);
}

private void reportError(String msg) {
	if (callback != null)
		callback.onIQSourceError(this, msg);
	else
		Log.e(LOGTAG, "Callback is null when reporting Error (" + msg + ")");
}

@Override
public boolean open(Context context, Callback callback) {
	this.callback = callback;
	// open the file
	try {
		this.bufferedInputStream = new BufferedInputStream(new FileInputStream(file));
		reopenStreamStrategy = file.length() > REOPEN_STREAM_SIZE_THRESHOLD;
		Log.i(LOGTAG, "File size: " + file.length() + " bytes");
		Log.i(LOGTAG, "Reopen threshold: " + REOPEN_STREAM_SIZE_THRESHOLD + " bytes");
		if (reopenStreamStrategy)
			Log.i(LOGTAG, "Using reopen stream strategy");
		else
			Log.i(LOGTAG, "Using reset stream strategy");
		if (!reopenStreamStrategy) this.bufferedInputStream.mark((int) file.length());
		callback.onIQSourceReady(this);
		return true;
	}
	catch (IOException e) {
		Log.e(LOGTAG, "open: Error while opening file: " + e.getMessage());
		reportError("Error while opening file: " + e.getMessage());
		return false;
	}
}

@Override
public boolean isOpen() {
	if (bufferedInputStream == null)
		return false;
	try {
		if (bufferedInputStream.available() > 0)
			return true;
	}
	catch (IOException e) {

	}
	return false;
}

@Override
public boolean close() {
	// close the file
	try {
		if (bufferedInputStream != null)
			bufferedInputStream.close();
		return true;
	}
	catch (IOException e) {
		Log.e(LOGTAG, "stopSampling: Error while closing file: " + e.getMessage());
		reportError("Unexpected error while closing file: " + e.getMessage());
		return false;
	}
}

@Override
public String getName() {
	return "IQ-File: " + file.getName();
}

@Override
public FileIQSource updatePreferences(Context context, SharedPreferences preferences) {
	int fileFormat = Integer.parseInt(preferences.getString(context.getString(R.string.pref_filesource_format), "0"));
	String fileName = preferences.getString(context.getString(R.string.pref_filesource_file), "");
	if (fileFormat != this.fileFormat || !fileName.equals(this.filename)) {
		this.close();
		return new FileIQSource(context, preferences);
	}
	this.frequency = Integer.parseInt(preferences.getString(context.getString(R.string.pref_filesource_frequency), "97000000"));
	this.sampleRate = Integer.parseInt(preferences.getString(context.getString(R.string.pref_filesource_sampleRate), "2000000"));
	this.repeat = preferences.getBoolean(context.getString(R.string.pref_filesource_repeat), false);
	return this;
}

/**
 * @return the file name of the file
 */
public String getFilename() {
	return filename;
}

/**
 * @return true if repeat is enabled; false if not
 */
public boolean isRepeat() {
	return repeat;
}

/**
 * @return the format of the file: FILE_FORMAT_8BIT_SIGNED, ...
 */
public int getFileFormat() {
	return fileFormat;
}

private RXSampleRate rxSampleRateControl = new RXSampleRate() {
	private final String LOGTAG = "[File]:SampleRate";

	@Override
	public Integer get() {
		return sampleRate;
	}

	@Override
	public void set(Integer sampleRate) {
		Log.e(LOGTAG, "Setting the sample rate is not supported on a file source");
	}


	@Override
	public Integer getMax() {
		return FileIQSource.this.sampleRate;
	}

	@Override
	public Integer getMin() {
		return FileIQSource.this.sampleRate;
	}

	@Override
	public int getNextHigherOptimalSampleRate(int sampleRate) {
		return FileIQSource.this.sampleRate;
	}

	@Override
	public int getNextLowerOptimalSampleRate(int sampleRate) {
		return FileIQSource.this.sampleRate;
	}

	@Override
	public int[] getSupportedSampleRates() {
		return new int[]{FileIQSource.this.sampleRate};
	}
};
private RXFrequency rxFrequencyControl = new FileRXFrequency(this);

@Override
public int getSampledPacketSize() {
	return packetSize;
}

@Override
public byte[] getPacket(int timeout) {
	if (bufferedInputStream == null)
		return null;

	try {
		// Simulate sample rate of real hardware:
		int sleep = Math.min(sleepTime - (int) (System.currentTimeMillis() - lastAccessTime), timeout);
		if (sleep > 0)
			SystemClock.sleep(sleep);

		// Read the samples.
		if (bufferedInputStream.read(buffer, 0, buffer.length) != buffer.length) {
			if (repeat) {
				if (reopenStreamStrategy) {
					// rewind and try again:
					Log.i(LOGTAG, "getPacket: End of File. Rewind!");
					bufferedInputStream.close();
					this.bufferedInputStream = new BufferedInputStream(new FileInputStream(file));
				} else {
					// reset stream and try again:
					Log.i(LOGTAG, "getPacket: End of File. Reset!");
					bufferedInputStream.reset();
				}
				if (bufferedInputStream.read(buffer, 0, buffer.length) != buffer.length)
					return null;
				else {
					lastAccessTime = System.currentTimeMillis();
					return buffer;
				}
			} else {
				Log.i(LOGTAG, "getPacket: End of File");
				reportError("End of File");
				return null;
			}
		}
	}
	catch (IOException e) {
		Log.e(LOGTAG, "getPacket: Error while reading from file: " + e.getMessage());
		reportError("Unexpected error while reading file: " + e.getMessage());
		return null;
	}

	lastAccessTime = System.currentTimeMillis();
	return buffer;
}

@Override
public void returnPacket(byte[] buffer) {
	// do nothing
}

@Override
public void startSampling() {
	// nothing to do here...
}

@Override
public void stopSampling() {
	// nothing to do here...
}

@Override
public int fillPacketIntoSamplePacket(byte[] packet, SamplePacket samplePacket) {
	return this.iqConverter.fillPacketIntoSamplePacket(packet, samplePacket, offset);
}

@Override
public int mixPacketIntoSamplePacket(byte[] packet, SamplePacket samplePacket, long channelFrequency) {
	return this.iqConverter.mixPacketIntoSamplePacket(packet, samplePacket, offset, channelFrequency);
}

private final Map<Class<? extends Control>, Control> controls = new HashMap<>();

{
	controls.put(RXFrequency.class, rxFrequencyControl);
	controls.put(RXSampleRate.class, rxSampleRateControl);
}

@Override
public <T extends Control> T getControl(Class<T> clazz) {
	return (T) controls.get(clazz);
}

@Override
public Collection<Control> getControls() {
	return Collections.unmodifiableCollection(controls.values());
}

}
